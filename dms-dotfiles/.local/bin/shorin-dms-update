#!/usr/bin/env bash

# ==============================================================================
# Shorin DMS Updater (Sync: Install & Remove & Config)
# ==============================================================================

set -o pipefail

# --- 1. Pre-Configuration (Language) ---
ORIGINAL_LANG="${LC_ALL:-${LC_MESSAGES:-${LANG}}}"
SHOW_HELP=false

if [[ "$ORIGINAL_LANG" == *"zh_CN"* ]]; then
    UI_LANG="zh"
else
    UI_LANG="en"
fi

# Force C locale for git/find consistency
export LC_ALL=C

# --- 2. Configuration ---
DOTFILES_REPO="$HOME/.local/share/shorin-dms"
BACKUP_ROOT="$HOME/.cache/shorin-dms-update"
BACKUP_FILE="$BACKUP_ROOT/backup.tar.gz"
BRANCH="main"
NEED_REBOOT=false  # 重启追踪标志

# [CONFIG] Remote Dependency List URL
APP_LIST_URL="https://raw.githubusercontent.com/SHORiN-KiWATA/shorin-arch-setup/refs/heads/main/dms-applist.txt"

# [NEW] State Management (For tracking removals)
STATE_DIR="$HOME/.local/state/shorin-dms"
LAST_KNOWN_LIST="$STATE_DIR/last_applist.txt"

# --- 3. Styles ---
H_RED='\033[1;31m'; H_GREEN='\033[1;32m'; H_YELLOW='\033[1;33m'; H_BLUE='\033[1;34m'; NC='\033[0m'

# --- 4. Localization Table ---
LANG_TABLE='
MSG_DESC          | Update Shorin DMS dotfiles and manage dependencies.          | 更新 Shorin DMS 配置文件并同步系统依赖。
MSG_FEAT_HEAD     | Features:                                                    | 功能特性：
MSG_FEAT_1        | - Safe Update: Git auto-stash and shallow rebase             | - 安全更新：Git 自动打包本地修改并浅层变基拉取
MSG_FEAT_2        | - Backup: Optional tarball backup before update              | - 备份机制：更新前可选创建压缩包备份
MSG_FEAT_3        | - Auto Link: Smart container-level symlinking                | - 自动链接：智能容器级软链接管理，不伤系统
MSG_FEAT_4        | - Dependency: Sync applist (Install New & Remove Old)        | - 依赖管理：同步云端清单（安装新增 & 询问卸载）
MSG_ASK_BACKUP    | [QUERY] Create a backup of current state? [Y/n]:             | [询问] 是否创建当前状态的备份? [Y/n]: 
MSG_BACKUP_ING    | Creating backup...                                           | 正在创建备份...
MSG_QUICKSAVE     | Snapper quicksave running...                                 | 正在创建 Snapper 快照...
MSG_BACKUP_DONE   | Backup completed.                                            | 备份完成
MSG_BACKUP_SKIP   | Backup skipped.                                              | 已跳过备份
MSG_CHECK_UPDATE  | Preparing to update from upstream...                         | 准备从上游仓库拉取更新...
MSG_LOCAL_CHANGE  | Auto-saving local modifications...                           | 正在自动打包本地修改...
MSG_PULLING       | Downloading and applying updates (Shallow Rebase)...         | 正在下载并合并上游代码...
MSG_CORE_OK       | Git repository update successful.                            | Git 仓库更新成功。
MSG_CONFLICT      | Update conflict. Please check repo manually.                 | 更新冲突，请手动进入仓库检查。
MSG_LINKING       | Refreshing config symlinks...                                | 正在刷新配置文件软链接...
MSG_CLEANING      | Cleaning up repository garbage...                            | 清理 Git 仓库缓存...
MSG_ALL_DONE      | Update Completed Successfully.                               | 所有更新流程执行完毕。
MSG_BACKUP_PATH   | Backup Path:                                                 | 备份存放路径:
MSG_ERR_REPO      | Repository not found:                                        | 未找到仓库:
MSG_FETCH_LIST    | Downloading dependency list from GitHub...                   | 正在从 GitHub 下载最新依赖清单...
MSG_FETCH_FAIL    | Failed to download dependency list. Skipping check.          | 无法下载依赖清单，跳过依赖同步。
MSG_INSTALL_DEPS  | Installing missing packages:                                 | 发现新增软件包，准备安装:
MSG_INSTALL_FAIL  | Installation failed. Please check dependencies manually.     | 自动安装失败，请稍后手动检查依赖。
MSG_DEPS_OK       | All dependencies are satisfied.                              | 所有系统依赖已满足。
MSG_CHECK_REMOVE  | Checking for removed packages...                             | 正在检查被上游移除的软件包...
MSG_ASK_REMOVE    | [QUERY] Package "%s" is removed from list. Uninstall? [Y/n]: | [询问] 软件包 "%s" 已被上游移除。是否在本地卸载? [Y/n]: 
MSG_REMOVING      | Removing selected packages...                                | 正在卸载选定的软件包...
MSG_REMOVE_FAIL   | Failed to remove packages.                                   | 卸载失败。
MSG_REBOOT_TIP    | Note: You may need to reboot for core changes to take effect.| 注意：核心组件可能已更新，建议重启系统生效。
'

while IFS='|' read -r v e c; do
    v=$(printf '%s' "$v" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    e=$(printf '%s' "$e" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    c=$(printf '%s' "$c" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    
    [ -z "$v" ] && continue
    case "$v" in \#*) continue ;; esac
    
    if [ "$UI_LANG" = "zh" ]; then
        eval "$v=\"$c\""
    else
        eval "$v=\"$e\""
    fi
done <<EOF
$LANG_TABLE
EOF

# --- 5. Helper Functions ---
log() { echo -e "${H_BLUE}[INFO]${NC} $1"; }
success() { echo -e "${H_GREEN}[OK]${NC} $1"; }
warn() { echo -e "${H_YELLOW}[WARN]${NC} $1"; }
error() { echo -e "${H_RED}[ERROR]${NC} $1"; exit 1; }

usage() {
    cat <<EOF
Usage: $(basename "$0") [options]

Options:
  --help, -h      Show this help and exit

Description:
  $MSG_DESC

$MSG_FEAT_HEAD
  $MSG_FEAT_1
  $MSG_FEAT_2
  $MSG_FEAT_3
  $MSG_FEAT_4
EOF
}

# --- Remote Dependency Manager ---
check_dependencies() {
    log "$MSG_FETCH_LIST"
    
    mkdir -p "$STATE_DIR"

    local raw_temp="/tmp/shorin_dms_deps_raw.txt"
    local new_clean_list="/tmp/shorin_dms_deps_clean.txt"
    local old_sorted="/tmp/shorin_dms_deps_old_sorted.txt"
    local new_sorted="/tmp/shorin_dms_deps_new_sorted.txt"

    if ! curl -sL "$APP_LIST_URL" -o "$raw_temp"; then
        warn "$MSG_FETCH_FAIL"
        return 0
    fi

    rm -f "$new_clean_list"
    touch "$new_clean_list"
    
    # 解析并清洗下载的列表
    while read -r line; do
        [ -z "$line" ] && continue
        local pkg_name=$(echo "$line" | sed 's/#.*//' | sed 's/AUR://' | awk '{print $1}' | tr -cd '[:alnum:]@._+\n-')
        [ -z "$pkg_name" ] && continue
        echo "$pkg_name" >> "$new_clean_list"
    done < "$raw_temp"
    rm -f "$raw_temp"

    # 对比找出需要移除的包
    if [ -f "$LAST_KNOWN_LIST" ]; then
        log "$MSG_CHECK_REMOVE"
        sort "$LAST_KNOWN_LIST" > "$old_sorted"
        sort "$new_clean_list" > "$new_sorted"
        local diff_pkgs=$(comm -23 "$old_sorted" "$new_sorted")
        rm -f "$old_sorted" "$new_sorted"

        local remove_candidates=()
        if [ -n "$diff_pkgs" ]; then
            while read -r pkg; do
                [ -z "$pkg" ] && continue
                if pacman -Q "$pkg" &> /dev/null; then
                    local msg_ask=$(printf "$MSG_ASK_REMOVE" "$pkg")
                    echo -ne "${H_YELLOW}${msg_ask}${NC} "
                    read -r confirm_rm < /dev/tty
                    confirm_rm=${confirm_rm:-Y}
                    if [[ "$confirm_rm" =~ ^[yY] ]]; then
                        remove_candidates+=("$pkg")
                    fi
                fi
            done <<< "$diff_pkgs"
        fi

        if [ ${#remove_candidates[@]} -gt 0 ]; then
            log "$MSG_REMOVING"
            if sudo pacman -Rns "${remove_candidates[@]}"; then
                 NEED_REBOOT=true
            else
                 warn "$MSG_REMOVE_FAIL"
            fi
        fi
    fi

    # 确定安装工具
    local helper=""
    if command -v paru &> /dev/null; then helper="paru"
    elif command -v yay &> /dev/null; then helper="yay"
    else helper="sudo pacman"; fi

    # 找出新增的缺失包
    local missing_pkgs=()
    while read -r pkg_name; do
        if ! pacman -Q "$pkg_name" &> /dev/null; then
            missing_pkgs+=("$pkg_name")
        fi
    done < "$new_clean_list"

    # 执行安装
    if [ ${#missing_pkgs[@]} -gt 0 ]; then
        warn "$MSG_INSTALL_DEPS ${missing_pkgs[*]}"
        if $helper -S --needed "${missing_pkgs[@]}"; then
            NEED_REBOOT=true
        else
            warn "$MSG_INSTALL_FAIL"
        fi
    else
        success "$MSG_DEPS_OK"
    fi

    # 更新状态文件
    cp "$new_clean_list" "$LAST_KNOWN_LIST"
    rm -f "$new_clean_list"
}

# --- Link Functions (Adapted for Shorin DMS safe symlinking) ---
link_subdir() {
    local sub_dir="$1"
    local src_base="$2"
    local target_base="$3"
    
    local full_src="$src_base/$sub_dir"
    local full_target="$target_base/$sub_dir"
    
    if [[ -d "$full_src" ]]; then
        mkdir -p "$full_target"
        
        shopt -s dotglob
        for item in "$full_src"/*; do
            [ -e "$item" ] || continue
            local item_name=$(basename "$item")
            
            rm -rf "$full_target/$item_name" 2>/dev/null
            ln -snf "$item" "$full_target/$item_name"
        done
        shopt -u dotglob
    fi
}

link_dotfiles() {
    local src="$1"
    local target="$2"
    link_subdir ".config" "$src" "$target"
    link_subdir ".local/bin" "$src" "$target"
    link_subdir ".local/share" "$src" "$target"
}


# --- 6. Argument Parsing ---
while [[ $# -gt 0 ]]; do
    case "$1" in
        --help|-h) usage; exit 0 ;;
        *) echo "Unknown option: $1"; usage; exit 1 ;;
    esac
done

# ==============================================================================
# Core Execution Flow
# ==============================================================================

if [ ! -d "$DOTFILES_REPO/.git" ]; then
    error "$MSG_ERR_REPO $DOTFILES_REPO"
fi

cd "$DOTFILES_REPO" || exit 1

# 1. Backup
mkdir -p "$BACKUP_ROOT"
BACKUP_DONE=false
echo -ne "${H_YELLOW}${MSG_ASK_BACKUP}${NC} "
read -r OPT_BACKUP
OPT_BACKUP=${OPT_BACKUP:-Y}

if [[ "$OPT_BACKUP" =~ ^[yY] ]]; then
    log "$MSG_BACKUP_ING"
    if type quicksave &>/dev/null; then
        log "$MSG_QUICKSAVE"
        quicksave -d quicksave-shorin-update || warn "Snapper quicksave failed, continuing with tar backup..."
    fi
    tar -czf "$BACKUP_FILE" -C "$DOTFILES_REPO" dms-dotfiles resources 2>/dev/null
    success "$MSG_BACKUP_DONE"
    BACKUP_DONE=true
else
    log "$MSG_BACKUP_SKIP"
fi

# 2. Update Logic (Robust Rebase)
log "$MSG_CHECK_UPDATE"
git config pull.rebase true

log "$MSG_LOCAL_CHANGE"
# 注入自动化身份，防止新系统首次运行无法 commit
git config user.name "Shorin Auto Updater"
git config user.email "updater@shorin.local"
git add .
git commit -m "chore: auto-save local DMS changes before update" >/dev/null 2>&1 || true

log "$MSG_PULLING"
# 浅层变基拉取，强制保留本地冲突
if git pull --depth 1 --rebase origin "$BRANCH" -X theirs; then
    success "$MSG_CORE_OK"
else
    git rebase --abort 2>/dev/null
    error "$MSG_CONFLICT"
fi

# 3. Check Dependencies
check_dependencies

# 4. Linking Dotfiles & Wallpapers
log "$MSG_LINKING"
DOTFILES_SRC="$DOTFILES_REPO/dms-dotfiles"
link_dotfiles "$DOTFILES_SRC" "$HOME"

# 补充 Vim 配置链接
if [ ! -e "$HOME/.vimrc" ] && [ -f "$DOTFILES_SRC/.vimrc" ]; then
    ln -sf "$DOTFILES_SRC/.vimrc" "$HOME/.vimrc"
fi 

# 更新全局 Quickload 脚本
if [ -f "$DOTFILES_SRC/.local/bin/quickload" ]; then
    sudo cp -f "$DOTFILES_SRC/.local/bin/quickload" "/usr/local/bin/quickload"
    sudo chmod +x "/usr/local/bin/quickload"
fi

# 同步壁纸目录
WALLPAPER_SOURCE_DIR="$DOTFILES_REPO/resources/Wallpapers"
WALLPAPER_DIR="$HOME/Pictures/Wallpapers"
mkdir -p "$HOME/Pictures"
rm -rf "$WALLPAPER_DIR" 2>/dev/null
ln -snf "$WALLPAPER_SOURCE_DIR" "$WALLPAPER_DIR"

# 5. Cleanup
log "$MSG_CLEANING"
git reflog expire --expire=now --all
git gc --prune=now 2>/dev/null

echo ""
echo -e "${H_GREEN}${MSG_ALL_DONE}${NC}"

if [ "$NEED_REBOOT" = true ]; then
    echo -e "${H_YELLOW}${MSG_REBOOT_TIP}${NC}"
fi

if [ "$BACKUP_DONE" = true ]; then
    echo -e "${H_BLUE}${MSG_BACKUP_PATH}${NC} $BACKUP_FILE"
fi
