#!/usr/bin/env bash

# ==============================================================================
# Shorin DMS Updater (Branch-Aware & Flexible Sync)
# ==============================================================================

set -o pipefail

# --- 1. 环境与语言配置 ---
ORIGINAL_LANG="${LC_ALL:-${LC_MESSAGES:-${LANG}}}"
UI_LANG=$([[ "$ORIGINAL_LANG" == *"zh_CN"* ]] && echo "zh" || echo "en")
export LC_ALL=C

# --- 2. 动态分支检测 ---
DOTFILES_REPO="$HOME/.local/share/shorin-dms"

if [[ -d "$DOTFILES_REPO/.git" ]]; then
    # 动态获取当前分支名，例如 symbols
    BRANCH=$(git -C "$DOTFILES_REPO" rev-parse --abbrev-ref HEAD)
else
    BRANCH="main"
fi

# 动态构建依赖清单 URL
APP_LIST_URL="https://raw.githubusercontent.com/SHORiN-KiWATA/shorin-arch-setup/refs/heads/${BRANCH}/dms-applist.txt"

# --- 3. 样式与状态管理 ---
STATE_DIR="$HOME/.local/state/shorin-dms"
LAST_KNOWN_LIST="$STATE_DIR/last_applist.txt"
H_RED='\033[1;31m'; H_GREEN='\033[1;32m'; H_YELLOW='\033[1;33m'; H_BLUE='\033[1;34m'; NC='\033[0m'

# --- 4. 自动化更新逻辑 (修正版) ---
check_dependencies() {
    echo -e "${H_BLUE}[INFO]${NC} 正在从分支 [${BRANCH}] 同步依赖清单..."
    mkdir -p "$STATE_DIR"
    local new_clean_list="/tmp/shorin_dms_deps_clean.txt"

    # 下载当前分支对应的依赖列表
    if ! curl -sL "$APP_LIST_URL" -o "$new_clean_list.raw"; then
        echo -e "${H_YELLOW}[WARN]${NC} 无法获取清单，请检查网络或分支名称。"
        return 0
    fi

    # 清洗数据：过滤注释和空行
    grep -vE "^\s*#|^\s*$" "$new_clean_list.raw" | sed 's/AUR://' | awk '{print $1}' > "$new_clean_list"
    
    # 依赖对比逻辑 (略，保持之前的 diff 逻辑)...
    # 1. 找出本地已安装但在清单中消失的包，询问是否卸载
    # 2. 找出清单中有但本地未安装的包，自动安装
    
    # 安装完成后更新状态
    cp "$new_clean_list" "$LAST_KNOWN_LIST"
}

# --- 核心更新流程 ---
log() { echo -e "${H_BLUE}[INFO]${NC} $1"; }

log "检测到当前分支: ${BRANCH}"

cd "$DOTFILES_REPO" || exit 1

# 1. Git 更新 (修正冲突策略)
# 如果你使用了 Include 模式，这里的 rebase 会非常顺滑
git config user.email "updater@shorin.local"
git config user.name "Shorin Auto Updater"
git add .
git commit -m "chore: auto-save local DMS changes" >/dev/null 2>&1 || true

log "正在执行浅层变基拉取 (Branch: ${BRANCH})..."
# 关键改动：移除 -X theirs 
# 如果你确定上游更新更重要，可以使用 -X ours (在 rebase 中 ours 是远程分支)
if git pull --depth 1 --rebase origin "$BRANCH"; then
    echo -e "${H_GREEN}[OK]${NC} 仓库代码同步成功。"
else
    echo -e "${H_RED}[ERROR]${NC} 发现严重冲突，请手动解决后执行 git rebase --continue"
    exit 1
fi

# 2. 检查并同步依赖
check_dependencies

# 3. 刷新软链接 (略，保持之前的 link_dotfiles 逻辑)...

echo -e "${H_GREEN}更新完成！${NC}"
